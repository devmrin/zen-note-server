require('dotenv').config();
const fastify = require('fastify')({ 
    logger: {
        level: 'info',
        redact: ['req.headers.authorization', 'req.headers.cookie'],
        serializers: {
            req: (req) => ({
                method: req.method,
                url: req.url,
                hostname: req.hostname,
                remoteAddress: req.ip,
                remotePort: req.socket?.remotePort,
                reqId: req.id
            }),
            res: (res) => ({
                statusCode: res.statusCode,
                reqId: res.request?.id
            })
        }
    },
    genReqId: () => require('crypto').randomUUID()
});
const crypto = require('crypto');
const cors = require('@fastify/cors');
const rateLimit = require('@fastify/rate-limit');
const Redis = require('ioredis');

// Single shared Redis client instance
const redis = new Redis(process.env.REDIS_URL);

redis.on('error', (err) => {
    fastify.log.error({ err }, 'Redis connection error');
});

// Register rate limiting
fastify.register(rateLimit, {
    max: 10, // 10 requests per minute
    timeWindow: '1 minute',
    errorResponseBuilder: function (request, context) {
        return {
            code: 429,
            error: 'Rate limit exceeded',
            message: `Rate limit exceeded, retry in ${Math.round(context.ttl / 1000)} seconds.`
        };
    }
});

// Register CORS with explicit credentials disabled
fastify.register(cors, {
    origin: 'https://zen.mrinmay.dev',
    methods: ['GET', 'POST', 'OPTIONS'],
    credentials: false
});

// Input validation schemas
const shareSchema = {
    type: 'object',
    required: ['title', 'content'],
    properties: {
        title: {
            type: 'string',
            minLength: 1,
            maxLength: 200,
            pattern: '^[\\s\\S]*$' // Allow any characters but enforce length
        },
        content: {
            type: 'string',
            minLength: 1,
            maxLength: 50000 // 50KB limit
        }
    },
    additionalProperties: false
};

const shareIdSchema = {
    type: 'object',
    required: ['shareId'],
    properties: {
        shareId: {
            type: 'string',
            pattern: '^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$' // UUID format
        }
    },
    additionalProperties: false
};

fastify.get('/', async (request, reply) => {
    return { hello: 'world' };
});

fastify.post('/api/share', {
    schema: {
        body: shareSchema
    }
}, async (request, reply) => {
    try {
        const { title, content } = request.body;

        // Sanitize inputs (basic HTML entity encoding)
        const sanitizedTitle = title.replace(/[<>&"']/g, (char) => {
            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#x27;' };
            return entities[char];
        });
        
        const sanitizedContent = content.replace(/[<>&"']/g, (char) => {
            const entities = { '<': '&lt;', '>': '&gt;', '&': '&amp;', '"': '&quot;', "'": '&#x27;' };
            return entities[char];
        });

        const shareId = crypto.randomUUID();
        const redisKey = `note:${shareId}`;
        const note = { 
            title: sanitizedTitle, 
            content: sanitizedContent,
            createdAt: new Date().toISOString()
        };

        // Store as plain string with 60s TTL
        await redis.set(redisKey, JSON.stringify(note), 'EX', 60);

        fastify.log.info({ shareId, titleLength: title.length, contentLength: content.length }, 'Note shared successfully');

        return {
            sharePath: `/share/${shareId}`
        };
    } catch (err) {
        fastify.log.error({ err, reqId: request.id }, 'Error in POST /api/share');
        return reply.status(500).send({ error: 'Internal Server Error' });
    }
});

fastify.get('/api/shared/:shareId', {
    schema: {
        params: shareIdSchema
    }
}, async (request, reply) => {
    try {
        const { shareId } = request.params;
        const redisKey = `note:${shareId}`;

        const data = await redis.get(redisKey);

        if (!data) {
            fastify.log.info({ shareId, reqId: request.id }, 'Note not found or expired');
            return reply.status(404).send({ error: 'Note not found or expired' });
        }

        const note = JSON.parse(data);
        fastify.log.info({ shareId, reqId: request.id }, 'Note retrieved successfully');
        return note;
    } catch (err) {
        fastify.log.error({ err, shareId: request.params.shareId, reqId: request.id }, 'Error in GET /api/shared/:shareId');
        return reply.status(500).send({ error: 'Internal Server Error' });
    }
});

// Graceful shutdown hook
fastify.addHook('onClose', async (instance, done) => {
    try {
        fastify.log.info('Shutting down server gracefully...');
        await redis.quit();
        fastify.log.info('Redis connection closed');
        done();
    } catch (err) {
        fastify.log.error({ err }, 'Error during graceful shutdown');
        done(err);
    }
});

// Handle process signals for graceful shutdown
process.on('SIGINT', () => {
    fastify.log.info('Received SIGINT, shutting down gracefully');
    fastify.close();
});

process.on('SIGTERM', () => {
    fastify.log.info('Received SIGTERM, shutting down gracefully');
    fastify.close();
});

const start = async () => {
    try {
        const port = Number(process.env.PORT) || 3000;
        await fastify.listen({ port, host: '0.0.0.0' });
        fastify.log.info(`Server listening at http://0.0.0.0:${port}`);
    } catch (err) {
        fastify.log.error(err);
        process.exit(1);
    }
};

start();
